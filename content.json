{"pages":[{"title":"404 - Not Found","text":"","link":"/404.html"},{"title":"档案","text":"","link":"/archives/index.html"},{"title":"关于我","text":"","link":"/about/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"","link":"/friend/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"留言","text":"","link":"/message/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Java设计模式解析：迭代器模式的实现与应用","text":"迭代器模式是一种行为型设计模式，它提供了一种统一的方式来遍历集合中的元素，而无需暴露集合的内部结构。在本文中，我们将深入探讨迭代器模式的实现和应用。 在软件开发中，集合是一种常见的数据结构，用于存储和管理一组对象。通常，我们需要遍历集合中的元素以执行特定的操作。然而，集合的内部结构可能会发生变化，例如，我们可能会改变集合的实现方式或者添加新的集合类型。如果我们直接在代码中使用集合的特定方法来遍历元素，那么当集合发生变化时，我们需要修改所有使用该集合的代码。这将导致代码的不稳定性和维护困难。 迭代器模式的核心思想是将集合的遍历与集合的实现分离，以提供一种统一的遍历方式。迭代器模式定义了一个迭代器接口，该接口包含了遍历集合的方法。集合类实现迭代器接口，提供了获取迭代器的方法，并将遍历集合的操作委托给迭代器。这样，无论集合的内部结构如何变化，都不会影响到遍历集合的代码。 让我们通过一个示例来理解迭代器模式的具体实现。 首先，我们定义一个迭代器接口，包含了以下方法： 1234public interface Iterator&lt;T&gt; { boolean hasNext(); T next();} 然后，我们创建一个集合类，实现迭代器接口，并提供获取迭代器的方法： 1234567891011121314151617181920212223242526public class MyCollection&lt;T&gt; implements Iterator&lt;T&gt; { private T[] elements; private int position; public MyCollection(T[] elements) { this.elements = elements; this.position = 0; } @Override public boolean hasNext() { return position &lt; elements.length; } @Override public T next() { if (hasNext()) { return elements[position++]; } return null; } public Iterator&lt;T&gt; getIterator() { return this; }} 最后，我们可以使用迭代器来遍历集合中的元素： 1234567891011public class Main { public static void main(String[] args) { String[] names = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;}; MyCollection&lt;String&gt; collection = new MyCollection&lt;&gt;(names); Iterator&lt;String&gt; iterator = collection.getIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } }} 在上面的示例中，我们创建了一个包含三个字符串的集合，并使用迭代器来遍历集合中的元素。通过调用hasNext()方法来判断是否还有下一个元素，通过调用next()方法来获取下一个元素。 迭代器模式的优点是将集合的遍历与集合的实现解耦，使得代码更加灵活和可扩展。当集合的内部结构发生变化时，我们只需要修改集合类的实现，而不需要修改遍历集合的代码。 总结起来，迭代器模式提供了一种统一的遍历集合的方式，使得代码更加灵活和可扩展。通过将遍历操作封装在迭代器中，我们可以轻松地在不同的集合类型之间切换，而无需修改遍历代码。这使得迭代器模式成为一种非常有用的设计模式，在实际开发中被广泛应用。","link":"/posts/166597485.html"},{"title":"MySQL数据库管理的基本原则和技巧","text":"MySQL数据库是一种常用的关系型数据库管理系统，用于存储和管理大量的数据。在进行MySQL数据库管理时，有一些基本原则和技巧可以帮助我们更有效地管理数据库。 数据库设计原则： 合理规划数据表结构： 根据数据之间的关系和业务需求，设计合理的数据表结构，避免冗余和重复的数据。使用适当的数据类型： 根据数据的特点和存储需求，选择合适的数据类型，减少存储空间的浪费。设计有效的索引： 根据查询需求和数据表的大小，设计适当的索引，提高查询效率。 数据库优化技巧：使用批量操作： 在插入、更新或删除大量数据时，使用批量操作可以减少与数据库的交互次数，提高性能。合理使用缓存： 利用MySQL的缓存机制，将经常访问的数据缓存在内存中，减少对磁盘的访问，提高查询速度。分区管理数据： 对于大型数据库，可以将数据按照某种规则进行分区存储，提高查询效率和管理灵活性。定期优化数据库：定期进行数据库的优化操作，如表优化、索引优化和统计信息更新，提高数据库的性能和稳定性。数据库备份和恢复： 定期备份数据库： 定期备份数据库是非常重要的，可以保护数据免受意外删除、硬件故障或人为错误的影响。使用适当的备份策略： 根据数据的重要性和变化频率，选择合适的备份策略，如完全备份、增量备份或差异备份。测试备份和恢复过程： 在实际发生数据丢失或损坏之前，定期测试备份和恢复过程，确保备份数据的完整性和可用性。下面是一些MySQL数据库管理的示例代码： 创建数据表： 12345CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50), email VARCHAR(50)); 插入数据： 12INSERT INTO users (name, email) VALUES ('John', 'john@example.com');INSERT INTO users (name, email) VALUES ('Jane', 'jane@example.com'); 查询数据： 12SELECT * FROM users;SELECT * FROM users WHERE name = 'John'; 更新数据： 1UPDATE users SET email = 'john@example.org' WHERE id = 1; 删除数据： 1DELETE FROM users WHERE id = 2; 以上是MySQL数据库管理的基本原则和技巧，通过合理的数据库设计、优化和备份策略，我们可以更好地管理和保护数据库中的数据。同时，掌握MySQL的基本操作和语法，可以更高效地进行数据库管理和查询操作。","link":"/posts/812346519.html"},{"title":"SpringBoot核心框架之AOP详解","text":"SpringBoot核心框架之AOP详解一、AOP基础1.1 AOP概述 AOP：Aspect Oriented Programming（面向切面编程，面向方面编程），其实就是面向特定方法编程。 场景：项目部分功能运行较慢，定位执行耗时较长的业务方法，此时就需要统计每一个业务的执行耗时。 思路：给每个方法在开始前写一个开始计时的逻辑，在方法结束后写一个计时结束的逻辑，然后相减得到运行时间。 思路是没问题的，但是有个问题，一个项目是有很多方法的，如果挨个增加逻辑代码，会相当繁琐，造成代码的臃肿，所以可以使用AOP编程，将计时提出成一个这样的模板： 获取方法运行开始时间 运行原始方法 获取方法运行结束时间，计算执行耗时 原始方法就是我们需要计算时间的方法，并且可以对原始方法进行增强，其实这个技术就是用到了我们在Java基础部分学习的动态代理技术。 实现：动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要是通过底层的动态代理机制，对特点的方法进行编程。 1.2 AOP快速入门统计各个业务层方法执行耗时 导入依赖：在pom.xml中导入AOP的依赖。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 编写AOP程序：针对于特定方法根据业务需要进行编程。 12345678910111213141516171819202122232425262728293031@Slf4j // 日志@Component // 将当前类交给spring管理@Aspect // 声明这是一个AOP类public class TimeAspect { @Around(&quot;execution(* com.example.service.*.*(..))&quot;) // @Around：表示这是一个环绕通知。 // &quot;execution(* com.example.service.*.*(..))&quot;：切入点表达式，它定义了哪些方法会被这个环绕通知所拦截。这个后面会详细讲解。 // execution(* ...)：表示拦截执行的方法。 // * com.example.service.*.*(..)：表示拦截 com.example.service 包下所有类的所有方法（* 表示任意字符的通配符）。 // ..：表示方法可以有任意数量和类型的参数。 public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable { // ProceedingJoinPoint是 Spring AOP 中的一个接口，在使用环绕通知时需要 // 它继承自 JoinPoint 接口，并添加了 proceed() 方法。 // 这个方法是 AOP 代理链执行的关键部分，它允许你在切面中执行自定义逻辑后继续执行原始方法。 // 1. 记录开始时间 long start = System.currentTimeMillis(); // 2. 调用原始方法 Object result = joinPoint.proceed(); // 执行被通知的方法。如果不调用 proceed()，被通知的方法将不会执行。 // 3. 记录结束时间，计算耗时 long end = System.currentTimeMillis(); // getSignature()：返回当前连接点的签名。 log.info(joinPoint.getSignature()+&quot;方法执行耗时：{}ms&quot;,end - start); return result; }} 查看结果 这样我们就完成了，一个AOP的小例子，但是AOP的功能远不能这些，他还有更多的实用的功能。比如：记录操作日志：可以记录谁什么时间操作了什么方法，传了什么参数，返回值是什么都可以很方便的实现。还有比如权限控制，事务管理等等。 我们来总结一下AOP的优势 代码无侵入 减少重复代码 提高开发效率 维护方便 1.3. AOP核心概念连接点：JoinPoint，可以被连接点控制的方法（暗含方法执行时的信息）。 在此例中就是需要被计算耗时的业务方法。通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）。在此例中就是计算耗时的逻辑代码。切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用。在此例中就是com.example.service 包下所有类的所有方法。切面：Aspect，描述通知与切入点的对应关系（通知+切入点）。在此例中就是TimeAspect方法。目标对象：Target，通知所应用的对象。在此例中就是通知com.example.service 包下所有类的所有方法。 1.4. AOP的执行流程因为SpringAOP是基于动态代理实现的，所有在方法运行时就会先为目标对象基于动态代理生成一个代理对象，为什么说AOP可以增强方法，就是因为有一个代理方法，然后在AOP执行时，Spring就会将通知添加到代理对象的方法前面，也就是记录开始时间的那个逻辑代码，然后调用原始方法，也就是需要计时的那个方法，此时代理对象已经把原始方法添加到代理对象里面了，然后执行调用原始方法下面的代码，在此例中就是计算耗时的那部分，AOP会把这部分代码添加到代理对象的执行方法的下面，这样代理对象就完成了对目标方法的增强，也就是添加了计时功能，最后在程序运行时自动注入的也就不是原来的对象，而是代理对象了，不过这些都是AOP自动完成，我们只需要编写AOP代码即可。 二、AOP进阶2.1. AOP支持的通知类型通知类型： 环绕通知（Around Advice） 重点！！！： 使用 @Around 注解来定义。 包围目标方法的执行，可以在方法执行前后执行自定义逻辑，并且可以控制目标方法的执行。 通过 ProceedingJoinPoint 参数的 proceed() 方法来决定是否执行目标方法。 前置通知（Before Advice）： 使用 @Before 注解来定义。 在目标方法执行之前执行，无论方法是否抛出异常，都会执行。 不能阻止目标方法的执行。 后置通知（After Advice） 也叫最终通知： 使用 @After 注解来定义。 在目标方法执行之后执行，无论方法是否抛出异常，都会执行。 通常用于资源清理工作 返回通知（After Returning Advice） 了解： 使用 @AfterReturning 注解来定义。 在目标方法成功执行之后执行，即没有抛出异常时执行。 可以获取方法的返回值。 异常通知（After Advice）了解： 使用 @AfterThrowing 注解来定义。 在目标方法抛出异常后执行。 可以获取抛出的异常对象。 注意事项： 环绕通知需要自己调用joinPoint.proceed()来让原始方法执行，其他通知则不需要。 环绕通知的返回值必须是Object,来接受原始方法的返回值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Slf4j@Component@Aspectpublic class MyAspect { // 因为示例中的切入点都是一样的，所以不用写多次切入表达式，创建一个方法即可。 // 此方法也可在其他AOP需要切入点的地方使用。 @Pointcut(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void pt(){} // 前置通知 @Before(&quot;pt()&quot;) public void Before(){ log.info(&quot;before ...&quot;); } // 环绕通知 @Around(&quot;pt()&quot;) public Object Around(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;around after ...&quot;); // 调用原始方法 Object proceed = joinPoint.proceed(); log.info(&quot;around after ...&quot;); return proceed; } // 后置通知 @After(&quot;pt()&quot;) public void After(){ log.info(&quot;after ...&quot;); } // 返回通知 @AfterReturning(&quot;pt()&quot;) public void Returning(){ log.info(&quot;returning ...&quot;); } // 异常通知 @AfterThrowing(&quot;pt()&quot;) public void Throwing(){ log.info(&quot;throwing ...&quot;); }} 2.2. 多个通知之间的执行顺序当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会执行。那么顺序是怎么的呢？我们先创建三个AOP程序，分别给他们创建一个前置通知和后置通知，然后启动程序观察他们的输出情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// MyAspect2@Slf4j@Component@Aspectpublic class MyAspect2 { @Before(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void befor(){ log.info(&quot;befor2 ...&quot;); } @After(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void after(){ log.info(&quot;after2 ...&quot;); }}// MyAspect3@Slf4j@Component@Aspectpublic class MyAspect3 { @Before(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void befor(){ log.info(&quot;befor3 ...&quot;); } @After(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void after(){ log.info(&quot;after3 ...&quot;); }}// MyAspect4@Slf4j@Component@Aspectpublic class MyAspect4 { @Before(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void befor(){ log.info(&quot;befor4 ...&quot;); } @After(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void after(){ log.info(&quot;after4 ...&quot;); }}// 输出结果 com.example.aop.MyAspect2 : befor2 ... com.example.aop.MyAspect3 : befor3 ... com.example.aop.MyAspect4 : befor4 ... com.example.aop.MyAspect4 : after4 ... com.example.aop.MyAspect3 : after3 ... com.example.aop.MyAspect2 : after2 ...// 然后我们把MyAspect2改成MyAspect5，但输出内容不变，我们来看一下输出结果 com.example.aop.MyAspect3 : befor3 ... com.example.aop.MyAspect4 : befor4 ... com.example.aop.MyAspect5 : befor2 ... com.example.aop.MyAspect5 : after2 ... com.example.aop.MyAspect4 : after4 ... com.example.aop.MyAspect3 : after3 ... 2.2.1 默认情况：执行顺序是和类名有关系的，对于目标方法前的通知字母越靠前的越先执行，目标方法后的通知则相反，字母越靠前的越晚执行，这和Filter拦截器的规则是一样的。 2.2.2 也可以使用注解的方式指定顺序。使用@Order(数字)加在切面类上来控制顺序。目标方法前的通知：数字小的先执行。目标方法后的通知：数字小的后执行。 123456789@Slf4j@Component@Aspect@Order(10)public class MyAspect3 { ...} 2.3. 切入点表达式切入点表达式：描述切入点方法的一种表达式。作用：主要决定项目中哪些方法需要加入通知。常见形式： execution(…)：根据方法的签名来匹配。 @annotation：根据注解匹配。 2.3.1 execution(…)execution主要是通过方法的返回值，类名，包名，方法名，方法参数等信息来匹配，语法为：execution(访问修饰符？ 返回值 包名.类名.?方法名(方法参数) throws 异常) 其中带 ? 的表示可以省略的部分 访问修饰符：可省略（比如：public private …） 包名.类名：可省略 但不推荐 throws 异常：可省略 （注意是方法上声明可抛出的异常，不是实际抛出的异常） 12345// 完整的写法：@Before(&quot;execution(public void com.example.service.impl.DeptServiceImpl.add(java.lang.Integer))&quot;)public void befor(){ ...} 可以使用通配符描述切入点 单个独立的任意符号，可以通配任意返回值，包括包名，类名，方法名，任意一个参数，也可以通配包，类，方法名的一部分。 1@After(&quot;execution(* com.*.service.*.add*(*))&quot;) 多个连续的任意符号，可以通配任意层级的包，或任意类型，任意个数的参数。 1@After(&quot;execution(* com.example..DeptService.*(..))&quot;) 根据业务的需要，也可以使用 且（&amp;&amp;），或（||），非（！）来组合切入点表达式。 1@After(&quot;execution(* com.example..DeptService.*(..)) || execution(* com.example.service.DeptService.*(..))&quot;) 2.3.2 @annotation：用于匹配标识有特定注解的方法语法：@annotation(注解的全类名) 先新建一个注解： 1234@Retention(RetentionPolicy.RUNTIME) // 用来描述有效时间，RUNTIMW：在运行时有效@Target(ElementType.METHOD) // 用来说明这个注解可以运行在哪里， METHOD：方法上public @interface MyLog {} 在目标方法上添加注解 123456789101112@MyLog@Overridepublic void delete(Integer id) { deptMapper.delect(id); // 根据id删除部门}@MyLog@Overridepublic void add(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.add(dept);} 在切入点表达式以注解的方式进行 1234@After(&quot;@annotation(com.example.aop.MyLog)&quot;)public void after(){ ...} 3.3. 连接点在Spring中使用JoinPoint抽象了连接点，用它可以获取方法执行时的相关信息，如目标类目，方法名，方法参数等。 对于环绕通知（@around），获取连接点信息只能使用ProceedingJoinPoint 对于其他四种通知，获取连接点信息只能使用JoinPoint，他是ProceedingJoinPoint的父类型。 123456789101112131415161718192021222324252627282930313233343536373839// 我们只在环绕通知中演示，因为API都是相同的@Component@Aspect@Slf4jpublic class MyAspect5 { @Pointcut(&quot;@annotation(com.example.aop.MyLog)&quot;) public void pt(){} @Before(&quot;pt()&quot;) public void before(JoinPoint joinPoint){ log.info(&quot;before ...&quot;); } @Around(&quot;pt()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;around ... before&quot;); // 1. 获取目标对象的类名 log.info(&quot;目标对象的类名:&quot;+joinPoint.getTarget().getClass().getName()); // 2. 获取目标方法的方法名 log.info(&quot;目标方法的方法名&quot;+joinPoint.getSignature().getName()); // 3. 目标方法运行时传入的参数 log.info(&quot;目标方法运行时传入的参数&quot;+ Arrays.toString(joinPoint.getArgs())); // 数组不能直接输出 // 4. 放行，目标方法执行 Object object = joinPoint.proceed(); // 5. 获取目标方法的返回值 log.info(&quot;目标方法的返回值&quot;+ object); log.info(&quot;around ... after&quot;); return object; }}// 查看结果com.example.aop.MyAspect5 : around ... beforecom.example.aop.MyAspect5 : 目标对象的类名:com.example.service.impl.DeptServiceImplcom.example.aop.MyAspect5 : 目标方法的方法名selectcom.example.aop.MyAspect5 : 目标方法运行时传入的参数[1]com.example.aop.MyAspect5 : before ...com.example.aop.MyAspect5 : 目标方法的返回值[Dept(id=1, name=学工部, createTime=2023-11-30T13:55:55, updateTime=2023-11-30T13:55:55)]com.example.aop.MyAspect5 : around ... after 三、AOP案例3.1. 分析需求：将项目中的增、删、改、相关接口的操作日志记录到数据库表中 操作日志包含：操作人，操作时间，执行方法的全类名，执行方法名，方法运行时的参数，返回值，方法运行时长。思路分析： 需要对方法添加统一的功能，使用AOP最方便，并且需要计算运行时长，所以使用 环绕通知 因为增删改的方法名没有规则，所以使用注解的方式写切入表达式步骤： 准备： 案例中引入AOP的起步依赖 设计数据表结构，并且引入对应的实体类 编码： 自定义注解：@Log 定义切面类，完成记录操作日志的逻辑代码 3.2. 开始干活3.2.1. 创建数据库： 1234567891011create table operate_log( id int unsigned primary key auto_increment comment 'ID', operate_user int unsigned comment '操作人ID', operate_time datetime comment '操作时间', class_name varchar(100) comment '操作的类名', method_name varchar(100) comment '操作的方法名', method_params varchar(1000) comment '方法参数', return_value varchar(2000) comment '返回值', cost_time bigint comment '方法执行耗时, 单位:ms') comment '操作日志表'; 3.2.2. 引入依赖 12345678910111213&lt;!-- AOP--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- fastJSON 阿里巴巴提供的转JSON的工具--&gt;&lt;!-- 因为返回值是一个json的，但数据库表需要的是字符串，所以使用此工具将json转换成String --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt;&lt;/dependency&gt; 3.2.3. 新建实体类 12345678910111213@Data@NoArgsConstructor@AllArgsConstructorpublic class OperateLog { private Integer id; //ID private Integer operateUser; //操作人ID private LocalDateTime operateTime; //操作时间 private String className; //操作类名 private String methodName; //操作方法名 private String methodParams; //操作方法参数 private String returnValue; //操作方法返回值 private Long costTime; //操作耗时} 3.2.4. 新建Mapper层 1234567@Mapperpublic interface OperateLogMapper { //插入日志数据 @Insert(&quot;insert into operate_log (operate_user, operate_time, class_name, method_name, method_params, return_value, cost_time) &quot; + &quot;values (#{operateUser}, #{operateTime}, #{className}, #{methodName}, #{methodParams}, #{returnValue}, #{costTime});&quot;) void insert(OperateLog log);} 3.2.5. 新建注解 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Log {} 3.2.6. 定义切面类，完成记录操作日志的逻辑代码 123456789101112131415161718192021222324252627282930313233343536373839404142@Component@Aspect@Slf4jpublic class LogAspect { @Autowired private HttpServletRequest request; @Autowired private OperateLogMapper operateLogMapper; @Around(&quot;@annotation(com.example.anno.Log)&quot;) public Object recordLog(ProceedingJoinPoint joinPoint) throws Throwable { //操作人ID 因为jwt令牌有登录人信息，所以解析jwt令牌就可以// String token = request.getHeader(&quot;token&quot;);// Claims claims = JwtUtils.parseJWT(token);// Integer user = (Integer) claims.get(&quot;id&quot;); // 使用链式编程 ↓↓↓ Integer user = (Integer) JwtUtils.parseJWT(request.getHeader(&quot;token&quot;)).get(&quot;id&quot;); //操作时间 LocalDateTime optionTime = LocalDateTime.now(); //操作类名 String className = joinPoint.getTarget().getClass().getName(); //操作方法名 String methodName = joinPoint.getSignature().getName(); //操作方法参数 String args = Arrays.toString(joinPoint.getArgs()); long start = System.currentTimeMillis(); // 记录方法开始运行时间 // 调用原始方法 Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); // 记录方法结束运行时间 //操作方法返回值 String returnValue = JSONObject.toJSONString(result); //操作耗时 long costTime = end - start; // 记录操作日志 OperateLog operateLog = new OperateLog(null, user, optionTime, className, methodName, args, returnValue, costTime); operateLogMapper.insert(operateLog); log.info(&quot;AOP记录操作日志：{}&quot;, operateLog); return result; }} 3.2.7. 给需要记录的方法上面添加自定义的注解 123456789101112131415161718192021// 这里就不一一展示了 /** * 根据id删除部门 */ @Log @DeleteMapping(&quot;/{id}&quot;) public Result delete(@PathVariable Integer id){ log.info(&quot;根据id删除部门：{}&quot;,id); deptService.delete(id); return Result.success(); } /** * 添加部门 */ @Log @PostMapping public Result add(@RequestBody Dept dept){ log.info(&quot;添加部门{}&quot;,dept); deptService.add(dept); return Result.success(); } 3.3. 查看结果刚刚进行了部门的增删改以及员工的增删改操作，我们查看数据库，看有没有被记录。 123451,1,2024-10-27 20:20:23,com.example.controller.DeptController,delete,[15],&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,402,1,2024-10-27 20:20:45,com.example.controller.DeptController,add,&quot;[Dept(id=null, name=测试部, createTime=null, updateTime=null)]&quot;,&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,53,1,2024-10-27 20:21:00,com.example.controller.EmpController,sava,&quot;[Emp(id=null, username=测试, password=null, name=测试, gender=1, image=, job=1, entrydate=2024-10-20, deptId=16, createTime=null, updateTime=null)]&quot;,&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,64,1,2024-10-27 20:23:01,com.example.controller.DeptController,add,&quot;[Dept(id=null, name=1, createTime=null, updateTime=null)]&quot;,&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,85,1,2024-10-27 20:23:18,com.example.controller.DeptController,delete,[17],&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,12 完全符合要求！！！！！！## SpringBoot核心框架之AOP详解 一、AOP基础1.1 AOP概述 AOP：Aspect Oriented Programming（面向切面编程，面向方面编程），其实就是面向特定方法编程。 场景：项目部分功能运行较慢，定位执行耗时较长的业务方法，此时就需要统计每一个业务的执行耗时。 思路：给每个方法在开始前写一个开始计时的逻辑，在方法结束后写一个计时结束的逻辑，然后相减得到运行时间。 思路是没问题的，但是有个问题，一个项目是有很多方法的，如果挨个增加逻辑代码，会相当繁琐，造成代码的臃肿，所以可以使用AOP编程，将计时提出成一个这样的模板： 获取方法运行开始时间 运行原始方法 获取方法运行结束时间，计算执行耗时 原始方法就是我们需要计算时间的方法，并且可以对原始方法进行增强，其实这个技术就是用到了我们在Java基础部分学习的动态代理技术。 实现：动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要是通过底层的动态代理机制，对特点的方法进行编程。 1.2 AOP快速入门统计各个业务层方法执行耗时 导入依赖：在pom.xml中导入AOP的依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 编写AOP程序：针对于特定方法根据业务需要进行编程。 12345678910111213141516171819202122232425262728293031@Slf4j // 日志@Component // 将当前类交给spring管理@Aspect // 声明这是一个AOP类public class TimeAspect { @Around(&quot;execution(* com.example.service.*.*(..))&quot;) // @Around：表示这是一个环绕通知。 // &quot;execution(* com.example.service.*.*(..))&quot;：切入点表达式，它定义了哪些方法会被这个环绕通知所拦截。这个后面会详细讲解。 // execution(* ...)：表示拦截执行的方法。 // * com.example.service.*.*(..)：表示拦截 com.example.service 包下所有类的所有方法（* 表示任意字符的通配符）。 // ..：表示方法可以有任意数量和类型的参数。 public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable { // ProceedingJoinPoint是 Spring AOP 中的一个接口，在使用环绕通知时需要 // 它继承自 JoinPoint 接口，并添加了 proceed() 方法。 // 这个方法是 AOP 代理链执行的关键部分，它允许你在切面中执行自定义逻辑后继续执行原始方法。 // 1. 记录开始时间 long start = System.currentTimeMillis(); // 2. 调用原始方法 Object result = joinPoint.proceed(); // 执行被通知的方法。如果不调用 proceed()，被通知的方法将不会执行。 // 3. 记录结束时间，计算耗时 long end = System.currentTimeMillis(); // getSignature()：返回当前连接点的签名。 log.info(joinPoint.getSignature()+&quot;方法执行耗时：{}ms&quot;,end - start); return result; }} 查看结果 这样我们就完成了，一个AOP的小例子，但是AOP的功能远不能这些，他还有更多的实用的功能。比如：记录操作日志：可以记录谁什么时间操作了什么方法，传了什么参数，返回值是什么都可以很方便的实现。还有比如权限控制，事务管理等等。 我们来总结一下AOP的优势 代码无侵入 减少重复代码 提高开发效率 维护方便 1.3. AOP核心概念连接点：JoinPoint，可以被连接点控制的方法（暗含方法执行时的信息）。 在此例中就是需要被计算耗时的业务方法。通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）。在此例中就是计算耗时的逻辑代码。切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用。在此例中就是com.example.service 包下所有类的所有方法。切面：Aspect，描述通知与切入点的对应关系（通知+切入点）。在此例中就是TimeAspect方法。目标对象：Target，通知所应用的对象。在此例中就是通知com.example.service 包下所有类的所有方法。 1.4. AOP的执行流程因为SpringAOP是基于动态代理实现的，所有在方法运行时就会先为目标对象基于动态代理生成一个代理对象，为什么说AOP可以增强方法，就是因为有一个代理方法，然后在AOP执行时，Spring就会将通知添加到代理对象的方法前面，也就是记录开始时间的那个逻辑代码，然后调用原始方法，也就是需要计时的那个方法，此时代理对象已经把原始方法添加到代理对象里面了，然后执行调用原始方法下面的代码，在此例中就是计算耗时的那部分，AOP会把这部分代码添加到代理对象的执行方法的下面，这样代理对象就完成了对目标方法的增强，也就是添加了计时功能，最后在程序运行时自动注入的也就不是原来的对象，而是代理对象了，不过这些都是AOP自动完成，我们只需要编写AOP代码即可。 二、AOP进阶2.1. AOP支持的通知类型通知类型： 环绕通知（Around Advice） 重点！！！： 使用 @Around 注解来定义。 包围目标方法的执行，可以在方法执行前后执行自定义逻辑，并且可以控制目标方法的执行。 通过 ProceedingJoinPoint 参数的 proceed() 方法来决定是否执行目标方法。 前置通知（Before Advice）： 使用 @Before 注解来定义。 在目标方法执行之前执行，无论方法是否抛出异常，都会执行。 不能阻止目标方法的执行。 后置通知（After Advice） 也叫最终通知： 使用 @After 注解来定义。 在目标方法执行之后执行，无论方法是否抛出异常，都会执行。 通常用于资源清理工作 返回通知（After Returning Advice） 了解： 使用 @AfterReturning 注解来定义。 在目标方法成功执行之后执行，即没有抛出异常时执行。 可以获取方法的返回值。 异常通知（After Advice）了解： 使用 @AfterThrowing 注解来定义。 在目标方法抛出异常后执行。 可以获取抛出的异常对象。 注意事项： 环绕通知需要自己调用joinPoint.proceed()来让原始方法执行，其他通知则不需要。 环绕通知的返回值必须是Object,来接受原始方法的返回值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Slf4j@Component@Aspectpublic class MyAspect { // 因为示例中的切入点都是一样的，所以不用写多次切入表达式，创建一个方法即可。 // 此方法也可在其他AOP需要切入点的地方使用。 @Pointcut(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void pt(){} // 前置通知 @Before(&quot;pt()&quot;) public void Before(){ log.info(&quot;before ...&quot;); } // 环绕通知 @Around(&quot;pt()&quot;) public Object Around(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;around after ...&quot;); // 调用原始方法 Object proceed = joinPoint.proceed(); log.info(&quot;around after ...&quot;); return proceed; } // 后置通知 @After(&quot;pt()&quot;) public void After(){ log.info(&quot;after ...&quot;); } // 返回通知 @AfterReturning(&quot;pt()&quot;) public void Returning(){ log.info(&quot;returning ...&quot;); } // 异常通知 @AfterThrowing(&quot;pt()&quot;) public void Throwing(){ log.info(&quot;throwing ...&quot;); }} 2.2. 多个通知之间的执行顺序当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会执行。那么顺序是怎么的呢？我们先创建三个AOP程序，分别给他们创建一个前置通知和后置通知，然后启动程序观察他们的输出情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// MyAspect2@Slf4j@Component@Aspectpublic class MyAspect2 { @Before(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void befor(){ log.info(&quot;befor2 ...&quot;); } @After(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void after(){ log.info(&quot;after2 ...&quot;); }}// MyAspect3@Slf4j@Component@Aspectpublic class MyAspect3 { @Before(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void befor(){ log.info(&quot;befor3 ...&quot;); } @After(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void after(){ log.info(&quot;after3 ...&quot;); }}// MyAspect4@Slf4j@Component@Aspectpublic class MyAspect4 { @Before(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void befor(){ log.info(&quot;befor4 ...&quot;); } @After(&quot;execution(* com.example.service.impl.DeptServiceImpl.*(..))&quot;) public void after(){ log.info(&quot;after4 ...&quot;); }}// 输出结果 com.example.aop.MyAspect2 : befor2 ... com.example.aop.MyAspect3 : befor3 ... com.example.aop.MyAspect4 : befor4 ... com.example.aop.MyAspect4 : after4 ... com.example.aop.MyAspect3 : after3 ... com.example.aop.MyAspect2 : after2 ...// 然后我们把MyAspect2改成MyAspect5，但输出内容不变，我们来看一下输出结果 com.example.aop.MyAspect3 : befor3 ... com.example.aop.MyAspect4 : befor4 ... com.example.aop.MyAspect5 : befor2 ... com.example.aop.MyAspect5 : after2 ... com.example.aop.MyAspect4 : after4 ... com.example.aop.MyAspect3 : after3 ... 2.2.1 默认情况：执行顺序是和类名有关系的，对于目标方法前的通知字母越靠前的越先执行，目标方法后的通知则相反，字母越靠前的越晚执行，这和Filter拦截器的规则是一样的。 2.2.2 也可以使用注解的方式指定顺序。使用@Order(数字)加在切面类上来控制顺序。目标方法前的通知：数字小的先执行。目标方法后的通知：数字小的后执行。 123456789@Slf4j@Component@Aspect@Order(10)public class MyAspect3 { ...} 2.3. 切入点表达式切入点表达式：描述切入点方法的一种表达式。作用：主要决定项目中哪些方法需要加入通知。常见形式： execution(…)：根据方法的签名来匹配。 @annotation：根据注解匹配。 2.3.1 execution(…)execution主要是通过方法的返回值，类名，包名，方法名，方法参数等信息来匹配，语法为：execution(访问修饰符？ 返回值 包名.类名.?方法名(方法参数) throws 异常) 其中带 ? 的表示可以省略的部分 访问修饰符：可省略（比如：public private …） 包名.类名：可省略 但不推荐 throws 异常：可省略 （注意是方法上声明可抛出的异常，不是实际抛出的异常） 12345// 完整的写法：@Before(&quot;execution(public void com.example.service.impl.DeptServiceImpl.add(java.lang.Integer))&quot;)public void befor(){ ...} 可以使用通配符描述切入点 单个独立的任意符号，可以通配任意返回值，包括包名，类名，方法名，任意一个参数，也可以通配包，类，方法名的一部分。 1@After(&quot;execution(* com.*.service.*.add*(*))&quot;) 多个连续的任意符号，可以通配任意层级的包，或任意类型，任意个数的参数。 1@After(&quot;execution(* com.example..DeptService.*(..))&quot;) 根据业务的需要，也可以使用 且（&amp;&amp;），或（||），非（！）来组合切入点表达式。 1@After(&quot;execution(* com.example..DeptService.*(..)) || execution(* com.example.service.DeptService.*(..))&quot;) 2.3.2 @annotation：用于匹配标识有特定注解的方法语法：@annotation(注解的全类名) 先新建一个注解： 1234@Retention(RetentionPolicy.RUNTIME) // 用来描述有效时间，RUNTIMW：在运行时有效@Target(ElementType.METHOD) // 用来说明这个注解可以运行在哪里， METHOD：方法上public @interface MyLog {} 在目标方法上添加注解 123456789101112@MyLog@Overridepublic void delete(Integer id) { deptMapper.delect(id); // 根据id删除部门}@MyLog@Overridepublic void add(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.add(dept);} 在切入点表达式以注解的方式进行 1234@After(&quot;@annotation(com.example.aop.MyLog)&quot;)public void after(){ ...} 3.3. 连接点在Spring中使用JoinPoint抽象了连接点，用它可以获取方法执行时的相关信息，如目标类目，方法名，方法参数等。 对于环绕通知（@around），获取连接点信息只能使用ProceedingJoinPoint 对于其他四种通知，获取连接点信息只能使用JoinPoint，他是ProceedingJoinPoint的父类型。 123456789101112131415161718192021222324252627282930313233343536373839// 我们只在环绕通知中演示，因为API都是相同的@Component@Aspect@Slf4jpublic class MyAspect5 { @Pointcut(&quot;@annotation(com.example.aop.MyLog)&quot;) public void pt(){} @Before(&quot;pt()&quot;) public void before(JoinPoint joinPoint){ log.info(&quot;before ...&quot;); } @Around(&quot;pt()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;around ... before&quot;); // 1. 获取目标对象的类名 log.info(&quot;目标对象的类名:&quot;+joinPoint.getTarget().getClass().getName()); // 2. 获取目标方法的方法名 log.info(&quot;目标方法的方法名&quot;+joinPoint.getSignature().getName()); // 3. 目标方法运行时传入的参数 log.info(&quot;目标方法运行时传入的参数&quot;+ Arrays.toString(joinPoint.getArgs())); // 数组不能直接输出 // 4. 放行，目标方法执行 Object object = joinPoint.proceed(); // 5. 获取目标方法的返回值 log.info(&quot;目标方法的返回值&quot;+ object); log.info(&quot;around ... after&quot;); return object; }}// 查看结果com.example.aop.MyAspect5 : around ... beforecom.example.aop.MyAspect5 : 目标对象的类名:com.example.service.impl.DeptServiceImplcom.example.aop.MyAspect5 : 目标方法的方法名selectcom.example.aop.MyAspect5 : 目标方法运行时传入的参数[1]com.example.aop.MyAspect5 : before ...com.example.aop.MyAspect5 : 目标方法的返回值[Dept(id=1, name=学工部, createTime=2023-11-30T13:55:55, updateTime=2023-11-30T13:55:55)]com.example.aop.MyAspect5 : around ... after 三、AOP案例3.1. 分析需求：将项目中的增、删、改、相关接口的操作日志记录到数据库表中 操作日志包含：操作人，操作时间，执行方法的全类名，执行方法名，方法运行时的参数，返回值，方法运行时长。思路分析： 需要对方法添加统一的功能，使用AOP最方便，并且需要计算运行时长，所以使用 环绕通知 因为增删改的方法名没有规则，所以使用注解的方式写切入表达式步骤： 准备： 案例中引入AOP的起步依赖 设计数据表结构，并且引入对应的实体类 编码： 自定义注解：@Log 定义切面类，完成记录操作日志的逻辑代码 3.2. 开始干活3.2.1. 创建数据库： 1234567891011create table operate_log( id int unsigned primary key auto_increment comment 'ID', operate_user int unsigned comment '操作人ID', operate_time datetime comment '操作时间', class_name varchar(100) comment '操作的类名', method_name varchar(100) comment '操作的方法名', method_params varchar(1000) comment '方法参数', return_value varchar(2000) comment '返回值', cost_time bigint comment '方法执行耗时, 单位:ms') comment '操作日志表'; 3.2.2. 引入依赖 12345678910111213&lt;!-- AOP--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- fastJSON 阿里巴巴提供的转JSON的工具--&gt;&lt;!-- 因为返回值是一个json的，但数据库表需要的是字符串，所以使用此工具将json转换成String --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt;&lt;/dependency&gt; 3.2.3. 新建实体类 12345678910111213@Data@NoArgsConstructor@AllArgsConstructorpublic class OperateLog { private Integer id; //ID private Integer operateUser; //操作人ID private LocalDateTime operateTime; //操作时间 private String className; //操作类名 private String methodName; //操作方法名 private String methodParams; //操作方法参数 private String returnValue; //操作方法返回值 private Long costTime; //操作耗时} 3.2.4. 新建Mapper层 1234567@Mapperpublic interface OperateLogMapper { //插入日志数据 @Insert(&quot;insert into operate_log (operate_user, operate_time, class_name, method_name, method_params, return_value, cost_time) &quot; + &quot;values (#{operateUser}, #{operateTime}, #{className}, #{methodName}, #{methodParams}, #{returnValue}, #{costTime});&quot;) void insert(OperateLog log);} 3.2.5. 新建注解 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Log {} 3.2.6. 定义切面类，完成记录操作日志的逻辑代码 123456789101112131415161718192021222324252627282930313233343536373839404142@Component@Aspect@Slf4jpublic class LogAspect { @Autowired private HttpServletRequest request; @Autowired private OperateLogMapper operateLogMapper; @Around(&quot;@annotation(com.example.anno.Log)&quot;) public Object recordLog(ProceedingJoinPoint joinPoint) throws Throwable { //操作人ID 因为jwt令牌有登录人信息，所以解析jwt令牌就可以// String token = request.getHeader(&quot;token&quot;);// Claims claims = JwtUtils.parseJWT(token);// Integer user = (Integer) claims.get(&quot;id&quot;); // 使用链式编程 ↓↓↓ Integer user = (Integer) JwtUtils.parseJWT(request.getHeader(&quot;token&quot;)).get(&quot;id&quot;); //操作时间 LocalDateTime optionTime = LocalDateTime.now(); //操作类名 String className = joinPoint.getTarget().getClass().getName(); //操作方法名 String methodName = joinPoint.getSignature().getName(); //操作方法参数 String args = Arrays.toString(joinPoint.getArgs()); long start = System.currentTimeMillis(); // 记录方法开始运行时间 // 调用原始方法 Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); // 记录方法结束运行时间 //操作方法返回值 String returnValue = JSONObject.toJSONString(result); //操作耗时 long costTime = end - start; // 记录操作日志 OperateLog operateLog = new OperateLog(null, user, optionTime, className, methodName, args, returnValue, costTime); operateLogMapper.insert(operateLog); log.info(&quot;AOP记录操作日志：{}&quot;, operateLog); return result; }} 3.2.7. 给需要记录的方法上面添加自定义的注解 123456789101112131415161718192021// 这里就不一一展示了 /** * 根据id删除部门 */ @Log @DeleteMapping(&quot;/{id}&quot;) public Result delete(@PathVariable Integer id){ log.info(&quot;根据id删除部门：{}&quot;,id); deptService.delete(id); return Result.success(); } /** * 添加部门 */ @Log @PostMapping public Result add(@RequestBody Dept dept){ log.info(&quot;添加部门{}&quot;,dept); deptService.add(dept); return Result.success(); } 3.3. 查看结果刚刚进行了部门的增删改以及员工的增删改操作，我们查看数据库，看有没有被记录。 123451,1,2024-10-27 20:20:23,com.example.controller.DeptController,delete,[15],&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,402,1,2024-10-27 20:20:45,com.example.controller.DeptController,add,&quot;[Dept(id=null, name=测试部, createTime=null, updateTime=null)]&quot;,&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,53,1,2024-10-27 20:21:00,com.example.controller.EmpController,sava,&quot;[Emp(id=null, username=测试, password=null, name=测试, gender=1, image=, job=1, entrydate=2024-10-20, deptId=16, createTime=null, updateTime=null)]&quot;,&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,64,1,2024-10-27 20:23:01,com.example.controller.DeptController,add,&quot;[Dept(id=null, name=1, createTime=null, updateTime=null)]&quot;,&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,85,1,2024-10-27 20:23:18,com.example.controller.DeptController,delete,[17],&quot;{&quot;&quot;code&quot;&quot;:1,&quot;&quot;msg&quot;&quot;:&quot;&quot;success&quot;&quot;}&quot;,12 完全符合要求！！！！！！","link":"/posts/1566526591.html"},{"title":"Redis事务","text":"Redis 事务关系型数据中的事务都是原子性的，而redis 的事务是非原子性的。 Redis事务相关命令： MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。 EXEC：执行事务中的所有操作命令。 DISCARD：取消事务，放弃执行事务块中的所有命令。 WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。 UNWATCH：取消WATCH对所有key的监视。 DB事务和 redis事务对比 一致性（Consistency） 隔离性（Isolation） 持久性（Durability） 原子性（Atomicity） mysql 支持 支持 支持 支持 redis 支持 支持 不支持 不支持 事务演示执行执行一组事务命令 其中一条命令执行错误，后续的命令还是会继续执行。比如对string类型进行incr操作，并没有语法错误，但是会产生一个异常 基于WATCH对于事务作中断测试客户端&lt;1&gt; 客户端&lt;2&gt; 总结：1、当监控的key被其中一个事务修改后，那么另一个事务的执行将会被打断 2、n个事务事务开启，谁先exec谁成功，后面的exec会被打断","link":"/posts/1298018908.html"},{"title":"redis内存淘汰策略","text":"相关链接 redis LRU策略分析：https://www.cnblogs.com/linxiyue/p/10945216.html redis LFU策略分析：https://www.cnblogs.com/linxiyue/p/10955533.html redis LRU伪代码演示：https://github.com/mailjobblog/dev_redis/blob/master/LRU/LRU_Cache.php 内存淘汰策略 noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键 allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键 volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键 allkeys-random：加入键的时候如果过限，从所有key随机删除 volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐 volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键 volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 allkeys-lfu：从所有键中驱逐使用频率最少的键 LRU和LFU的区别LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面! LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页! LRU举例如下的访问模式，A每5s访问一次，B每2s访问一次，C与D每10s访问一次，|代表计算空闲时间的截止点： 1234~~~~~A~~~~~A~~~~~A~~~~A~~~~~A~~~~~A~~|~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~|~~~~~~~~~~C~~~~~~~~~C~~~~~~~~~C~~~~~~|~~~~~D~~~~~~~~~~D~~~~~~~~~D~~~~~~~~~D| 在很长时期内、可以看到，LRU对于A、B、C工作的很好，完美预测了将来被访问到的概率B&gt;A&gt;C，但对于D却预测了最少的空闲时间。 但是，总体来说，LRU算法已经是一个性能足够好的算法了 图解说明 新数据插入到链表头部 每当缓存命中（即缓存数据被访问），则将数据移到链表头部 当链表满的时候，将链表尾部的数据丢弃 LRU Cache具备的操作： set(key,value)：如果key在hashmap中存在，则先重置对应的value值，然后获取对应的节点cur，将cur节点从链表删除，并移动到链表的头部；若果key在hashmap不存在，则新建一个节点，并将节点放到链表的头部。当Cache存满的时候，将链表最后一个节点删除即可。 get(key)：如果key在hashmap中存在，则把对应的节点放到链表头部，并返回对应的value值；如果不存在，则返回-1。 LRU配置参数Redis配置中和LRU有关的有三个： maxmemory: 配置Redis存储数据时指定限制的内存大小，比如100m。当缓存消耗的内存超过这个数值时, 将触发数据淘汰。该数据配置为0时，表示缓存的数据量没有限制, 即LRU功能不生效。64位的系统默认值为0，32位的系统默认内存限制为3GB maxmemory_policy: 触发数据淘汰后的淘汰策略 maxmemory_samples: 随机采样的精度，也就是随即取出key的数目。该数值配置越大, 越接近于真实的LRU算法，但是数值越大，相应消耗也变高，对性能有一定影响，样本值默认为5。 LFU示例图展示 1234~~~~~A~~~~~A~~~~~A~~~~A~~~~~A~~~~~A~~|~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~|~~~~~~~~~~C~~~~~~~~~C~~~~~~~~~C~~~~~~|~~~~~D~~~~~~~~~~D~~~~~~~~~D~~~~~~~~~D| 在上面的情况中，在一定时期内，根据访问频繁情况，可以确定保留优先级：B&gt;A&gt;C=D。 LFU配置Redis4.0之后为maxmemory_policy淘汰策略添加了两个LFU模式： volatile-lfu：对有过期时间的key采用LFU淘汰算法 allkeys-lfu：对全部key采用LFU淘汰算法 还有2个配置可以调整LFU算法： 12lfu-log-factor 10lfu-decay-time 1 lfu-log-factor可以调整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。 lfu-decay-time是一个以分钟为单位的数值，可以调整counter的减少速度 内存淘汰策略的选择个人观点 我们在选择使用淘汰策略的时候可以根据访问key的方式来选择不同的淘汰策略 1、当我们redis中的key基本上都有用到，也就是说每个key都有周期性访问到，那就可以选择使用random策略 2、当我们redis中的key部分是我们经常访问的，部分是非经常访问的就可以考虑使用LRU和LFU策略 3、当我们想根据时间长久淘汰超时数据时，就选用ttl 4、我们根据我们的需要是否有要长久保存的key来选择volatile或者是all，如果有需要长久保存的key，则使用volatile，否则可以使用all全表扫描","link":"/posts/2661519066.html"},{"title":"Redis击穿-穿透-雪崩","text":"参考文献 [击穿，穿透，雪崩] 思维导图：https://kdocs.cn/l/sv1T3ny7wRQl布隆过滤器：https://blog.mailjob.net/posts/7164113.html Redis 缓存击穿1、形成原因：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。 2、解决方案1、增加互斥锁：基于 redis 或者 zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据2、设置用不过期：击穿采用互斥锁。可能会发生死锁、线程池阻塞等问题，建议：高热点key，写定时器更新key的过期时间，最好是在并发量最小的时候。 3、缓存击穿示例图 Redis 缓存穿透1、形成原因：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 2、解决方案1、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bit map中，一个一定不存在的数据会被 这个bit 数组拦截掉，从而避免了对底层存储系统的查询压力2、如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 3、缓存击穿示例图 Redis 缓存雪崩1、形成原因：当缓存服务器重启或者大量key集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力 2、解决方案1、保证高可用：做redis集群，哨兵。如果有的redis服务器出现宕机，切换到其他的节点2、后端限流削峰：利用redis lua做漏斗算法，其他的进程进行排队。降级服务，牺牲一些服务器，淘宝双十一的时候，就不允许查看一年前的订单也不允许退款3、过期时间错开，生成缓存的时候，一定时间内的过期时间随机生成。尽量避免大量缓存同一时间内失效 3、缓存击穿示例图","link":"/posts/403285957.html"},{"title":"Redis 日志showlog 和 管道pileline","text":"redis日志slowlog-log-slower-than：指定执行时间超过多少微秒(1秒等于1000000微秒) 的命令请求会被记录到日志上 slowlog-max-len：指定服务器最多保存多少条慢查询操作 设置slowlog有两种方式： 方式一：通过配置redis.conf文件进行配置 12345# 执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。slowlog-log-lower-than 1000 #最多能保存多少条日志slowlog-max-len 200 方式二：通过CONFIG命令进行配置 1234# 配置查询时间超过1毫秒的， 第一个参数单位是微秒&gt; CONFIG SET slowlog-log-slower-than 1000# 保存 100 条慢查记录&gt; config set slowlog-max-len 100 1127.0.0.1:6379 &gt; slowlog get 以windows为例查看记录如下 为了方便解说，我设置超时时间为0毫秒，日志记录为1条 那么记录的中的1）2）3）4）分别表示什么呢？ 1）表示日志唯一标识符uid 2）命令执行时系统的时间戳 3）命令执行的时长，以微妙来计算 4）命令和命令的参数 做日志查询的时候，可以通过3）来查看是具体的命令运行时间（注意：再强调一次，时间的单位是微妙，但对于一个插入操作来说，10000微妙，也就是10毫秒即0.01秒已经可以算是慢操作了） 需要去查看redis生成的持久型日志，这需要额外去配置一些内容，其中涉及到了集群和分布式， redis 管道 pileline1、未使用pipeline执行N条命令 2、使用了pipeline执行N条命令 3、两者性能对比 三、原生批命令(mset, mget)与Pipeline对比1、原生批命令是原子性，pipeline是非原子性 (原子性概念:一个事务是一个不可分割的最小工作单位,要么都成功要么都失败。原子操作是指你的一个业务逻辑必须是不可拆分的. 处理一件事情要么都成功，要么都失败，原子不可拆分) 2、原生批命令一命令多个key, 但pipeline支持多命令（存在事务），非原子性 3、原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成 4、使用pipeline组装的命令个数不能太多，不然数据量过大，增加客户端的等待时间，还可能造成网络阻塞，可以将大量命令的拆分多个小的pipeline命令完成 5、redis提供了mset、mget方法，但没有提供mdel方法，如果想实现，可以借助pipeline实现。 贴上代码1234567891011121314151617181920212223242526272829&lt;?php$stime=microtime(true); //获取程序开始执行的时间echo '开始内存：'.memory_get_usage(), ''; echo PHP_EOL;$redis = new \\Redis(); $redis-&gt;connect('192.168.29.108',6379);$redis-&gt;auth(&quot;root&quot;); //$pipe=$redis-&gt;multi($redis::PIPELINE);//将多个操作当成一个事务执行$pipe=$redis-&gt;pipeline();//（多条）执行命令简单的，更加快速的发送给服务器，但是没有任何原子性的保证 for($i= 0; $i&lt;10000 ; $i++) { $pipe-&gt;set(&quot;key::$i&quot;,str_pad($i,4,'0',0)); $pipe-&gt;get(&quot;key::$i&quot;); } $replies=$pipe-&gt;exec(); $etime=microtime(true);//获取程序执行结束的时间 $total=($etime-$stime); //计算差值 echo &quot;[页面执行时间：{$total} ]s&quot;; echo PHP_EOL;echo '运行后内存：'.memory_get_usage(), ''; echo PHP_EOL;","link":"/posts/283315164.html"},{"title":"使用Java MVC开发高效、可扩展的Web应用","text":"在当今的Web开发领域，高效和可扩展性是我们追求的目标。Java作为一种强大且广泛使用的编程语言，提供了丰富的工具和框架来支持Web应用的开发。其中，MVC模式是一种被广泛采用的架构模式，它能够有效地组织和管理代码，使得应用更易于理解、维护和扩展。 什么是MVC模式？ MVC模式是一种软件设计模式，旨在将一个应用程序划分为三个核心组件：模型（Model）、视图（View）和控制器（Controller）。每个组件有着明确的职责和功能，彼此之间相互独立，耦合度低。模型（Model）：模型负责处理应用程序的数据逻辑。它封装了数据的结构和操作方法，并提供对数据的访问接口。视图（View）：视图负责展示数据给用户，并接受用户的输入。它通常是用户界面的一部分，负责呈现数据，并将用户的操作转发给控制器进行处理。控制器（Controller）：控制器是模型和视图之间的协调者。它接收视图产生的用户输入，并根据输入更新模型的状态或执行相应的业务逻辑。控制器还负责将模型的变化反馈给视图，以便及时更新用户界面。通过将应用程序分解为这三个组件，MVC模式强调了代码的可重用性、可测试性和松耦合性。这使得应用程序更易于维护和扩展。 在Java中实现MVC模式 在Java中，我们可以使用许多框架和库来实现MVC模式。下面是一个简单的示例，展示了如何在Java中构建一个基本的MVC架构。定义模型（Model）：创建Java类来表示应用程序的数据模型，并实现相应的数据逻辑。创建视图（View）：开发用户界面，可以是基于Web的前端页面或者是桌面应用程序中的图形界面。实现控制器（Controller）：编写Java类来处理用户的输入，并根据需要更新模型的状态。控制器还负责将模型的数据传递给视图进行展示。使用Java MVC模式可以提供以下优势： 分离关注点：MVC模式将应用程序的不同方面分离开来，使得代码更具可读性和可维护性。开发人员可以独立地修改和扩展模型、视图和控制器，而无需影响其他部分的代码。可测试性：由于模型、视图和控制器之间的松耦合性，我们可以更轻松地编写单元测试和集成测试，确保应用程序的质量和稳定性。可重用性：通过将核心业务逻辑封装在模型中，我们可以将其在多个应用程序或不同的项目中进行重用，提高开发效率和代码共享。结论：本文介绍了使用Java MVC模式开发高效、可扩展的Web应用程序的方法。通过合理地组织和管理代码，我们可以实现代码的可维护性、可测试性和可扩展性。MVC模式的优势在于它提供清晰的分层结构和松耦合的组件，使得应用程序更易于开发和维护。 希望本文能对您理解和应用Java MVC模式有所帮助。谢谢阅读！","link":"/posts/2826338363.html"},{"title":"简化代码结构与提高灵活性：学习Java设计模式中的装饰器模式","text":"简化代码结构与提高灵活性：学习Java设计模式中的装饰器模式 在软件开发中，我们经常会遇到需要在不修改现有代码的情况下，对已有对象进行功能扩展或修改的需求。此时，装饰器模式就是一种非常有用的设计模式，它通过动态地将责任附加到对象上，来扩展对象的功能。本文将介绍装饰器模式的概念、应用场景以及如何使用Java设计模式中的装饰器模式来简化代码结构与提高灵活性。 概念介绍：装饰器模式是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊包装器中来为原始对象添加新的行为。这种模式可以在不改变原始对象的结构的情况下，动态地为对象添加功能。 在装饰器模式中，有四个核心角色： 抽象组件（Component）：定义了被装饰者的接口，可以是一个抽象类或接口。具体组件（Concrete Component）：实现了抽象组件的接口，是被装饰者的具体实现。抽象装饰器（Decorator）：继承或实现了抽象组件的接口，同时持有一个抽象组件的引用。具体装饰器（Concrete Decorator）：继承或实现了抽象装饰器，实现了对抽象组件的装饰。应用场景装饰器模式常用于以下场景： 在不改变已有代码的情况下，动态地扩展一个对象的功能。当需要为一个对象的功能添加多个不同的扩展时，使用继承会导致类的爆炸式增长，而装饰器模式可以灵活地组合这些扩展。需要为一个对象的功能添加和撤销多个装饰时，装饰器模式可以方便地进行动态添加和移除。示例代码假设我们有一个简单的咖啡店系统，其中有一个基础的咖啡组件和多个装饰器组件，分别代表不同的咖啡调料。我们可以使用装饰器模式来动态地为咖啡添加调料。 首先，我们定义一个抽象组件Coffee，它表示咖啡的接口： 1234public interface Coffee { String getDescription(); double getCost();} 然后，我们实现一个具体组件SimpleCoffee，它表示基础的咖啡： 1234567891011public class SimpleCoffee implements Coffee { @Override public String getDescription() { return &quot;Simple Coffee&quot;; } @Override public double getCost() { return 1.0; }} 接下来，我们定义一个抽象装饰器CoffeeDecorator，它继承了Coffee接口，并持有一个Coffee对象的引用： 1234567891011121314151617public abstract class CoffeeDecorator implements Coffee { protected Coffee coffee; public CoffeeDecorator(Coffee coffee) { this.coffee = coffee; } @Override public String getDescription() { return coffee.getDescription(); } @Override public double getCost() { return coffee.getCost(); }} 最后，我们实现具体装饰器MilkDecorator和SugarDecorator，它们分别代表添加牛奶和糖的咖啡调料： 12345678910111213141516171819202122232425262728293031public class MilkDecorator extends CoffeeDecorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public String getDescription() { return coffee.getDescription() + &quot;, Milk&quot;; } @Override public double getCost() { return coffee.getCost() + 0.5; }}public class SugarDecorator extends CoffeeDecorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public String getDescription() { return coffee.getDescription() + &quot;, Sugar&quot;; } @Override public double getCost() { return coffee.getCost() + 0.3; }} 现在，我们可以使用装饰器模式来创建一个具有不同调料的咖啡对象： 12345678910public class Main { public static void main(String[] args) { Coffee coffee = new SimpleCoffee(); coffee = new MilkDecorator(coffee); coffee = new SugarDecorator(coffee); System.out.println(&quot;Description: &quot; + coffee.getDescription()); System.out.println(&quot;Cost: &quot; + coffee.getCost()); }} 输出结果： 12Description: Simple Coffee, Milk, SugarCost: 1.8 通过装饰器模式，我们可以动态地为咖啡对象添加不同的调料，而不需要修改现有的代码。这样，我们可以灵活地组合不同的调料，实现更多种类的咖啡。 总结装饰器模式是一种非常有用的设计模式，它可以在不改变现有代码的情况下，动态地为对象添加功能。通过将责任附加到对象上的方式，装饰器模式可以实现代码的灵活复用和扩展。在实际开发中，我们可以使用装饰器模式来简化代码结构，提高代码的灵活性和可维护性。","link":"/posts/2751550177.html"}],"tags":[{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"Java设计模式解析","slug":"Java设计模式解析","link":"/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/"},{"name":"MySQL数据库管理的基本原则和技巧","slug":"MySQL数据库管理的基本原则和技巧","link":"/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E5%92%8C%E6%8A%80%E5%B7%A7/"},{"name":"redis","slug":"redis","link":"/categories/redis/"}]}